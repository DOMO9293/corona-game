/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import React, { useRef, useEffect, useCallback, useState } from "react";
import { useLoader, useFrame, useResource } from "react-three-fiber";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader";
import { a, useSpring } from "react-spring/three";
import { useBox } from "use-cannon";
import * as THREE from "three";
import useSound from "use-sound";

import { useOutline, useLife, usePlayerAttack, useCorona, COLLISION_GROUP } from "./store"
import playerHitSfx from './sounds/Player_Hit.wav'

const batMovements = {
  init: {
    t: 1,
    spring: {
      rotation: [Math.PI, -Math.PI / 12, -Math.PI],
      position: [0.1, 0.1, 0.1]
    }
  },
  half: {
    t: 5,
    spring: {
      rotation: [(-Math.PI * 2) / 6, Math.PI / 8, -Math.PI],
      position: [-0.5, -0.5, 0.2]
    }
  },
  end: {
    t: 15,
    spring: {
      rotation: [Math.PI / 2, -Math.PI / 24, -Math.PI],
      position: [0, 0, 0]
    }
  },
  idle: { t: 90 }
}

function PhyBaseballBat(props) {
  const onCollide = useRef()
  const [] = useSound(playerHitSfx)

  const { decrease } = useLife(s => s)
  const coronas = useCorona(s => s.coronas)

  const [mybody, api] = useBox(() => ({
    args: [0.03, 0.3, 0.03],
    type: "Kinematic",
    mass: 1,
    material: { friction: 1, restitution: 1 },
    linearDamping: 1,
    angularDamping: 1,
    collisionFilterGroup: COLLISION_GROUP.BAT,
    collisionFilterMask: COLLISION_GROUP.CORONA,
    onCollide: e => onCollide.current(e)
  }));

  const handleCollide = useCallback(
    function handleCollide(e) {
      const { body, contact } = e
      const { type, id } = body?.userData

      if (type === COLLISION_GROUP.CORONA) {
        const { isAttacking } = coronas?.filter(item => item.id === id)?.[0]

        if (isAttacking) {
          const { impactVelocity } = contact
          const absVelocity = Math.abs(impactVelocity)
          decrease(absVelocity)
        }

      }
    },
    [decrease, coronas]
  )

  useEffect(() => void (onCollide.current = handleCollide), [onCollide, handleCollide])

  return (
    <>
      <mesh ref={mybody} userData={{ type: COLLISION_GROUP.BAT }} />
      <BaseballBat api={api} {...props} />
    </>
  )
}

function BaseballBat(props) {
  const { callbacks, api, ...allTheRest } = props;

  const batRef = useRef()
  const batGroupRef = useRef()
  const time = useRef(batMovements.idle.t);

  const [attacked, setAttacked] = useState(false)

  const addOutline = useOutline(s => s.addOutline)
  const { setAttacking, resetAttacking } = usePlayerAttack(s => s)
  const life = useLife(s => s.life)

  const { nodes } = useLoader(
    GLTFLoader,
    "/baseball_bat.glb",
    loader => {
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath("/draco-gltf/");
      loader.setDRACOLoader(dracoLoader);
    }
  );

  const [spring, set] = useSpring(() => ({
    ...batMovements.end.spring,
    config: { mass: 1, tension: 210, friction: 10 }
  }));

  const handleClick = useCallback(
    function handleClick() {
      if (time.current > batMovements.end.t) {
        time.current = 0
      }
    },
    [time]
  )

  const [metalResourceRef, metalMaterial] = useResource()
  const [handleResourceRef, handleMaterial] = useResource()

  useEffect(() => void setAttacked(true), [life])

  useEffect(() => {
    if (attacked) {
      setTimeout(() => setAttacked(false), 200)
    }
  }, [attacked])

  useEffect(() => void callbacks.current.push(handleClick), [handleClick, callbacks]);

  useEffect(() => void addOutline(batGroupRef.current), [addOutline, batGroupRef]);

  useFrame(() => {
    const { init, half, end, idle } = batMovements
    time.current += 1;

    if (time.current === init.t) {

      setAttacking()
      batGroupRef.current.rotation.x = Math.PI / 2;
      batGroupRef.current.rotation.y = 0;
      set({ ...init.spring });

    } else if (time.current === half.t) {

      set({ ...half.spring });

    } else if (time.current === end.t) {

      resetAttacking()
      set({ ...end.spring });

    } else if (time.current > idle.t) {

      batGroupRef.current.rotation.x = Math.PI / 2 + Math.cos(time.current / 10) / 6
      batGroupRef.current.rotation.y = Math.sin(time.current / 10) / 6;

    }
    
    const position = new THREE.Vector3();
    const quaternion = new THREE.Quaternion();
    const euler = new THREE.Euler();
  
    batRef.current.matrixWorld.decompose(position, quaternion, {});
    euler.setFromQuaternion(quaternion)
  
    api.position.set(position.x, position.y, position.z);
    api.rotation.set(euler.x, euler.y, euler.z);
  });

  return (
    <>
      <meshToonMaterial
        color={attacked ? 0x76747E : 0xB8B5C3}
        shininess={0.3}
        specular={0xaaaaaa}
        ref={metalResourceRef}
      />
      <meshToonMaterial
        color={attacked ? 0x740000 : 0x454194}
        shininess={0.3}
        specular={0x888888}
        ref={handleResourceRef}
      />

      <group ref={batGroupRef} {...allTheRest} rotation={[Math.PI / 2, 0, 0]} dispose={null}>
        <a.group scale={[0.02, 0.12, 0.02]} {...spring} >
          <mesh position={[0, 2.5, 0]} ref={batRef} />
          <mesh material={metalMaterial} geometry={nodes.Cylinder_1.geometry} />
          <mesh material={handleMaterial} geometry={nodes.Cylinder_0.geometry} />
          <mesh material={handleMaterial} geometry={nodes.Cylinder_2.geometry} />
        </a.group>
      </group>
    </>
  );
}

export default PhyBaseballBat
/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import React, { useRef, useEffect, useCallback, forwardRef, Suspense } from 'react'
import { useFrame, useResource } from 'react-three-fiber'
import { useSphere } from 'use-cannon';
import { useSpring, a, config } from 'react-spring/three';
import * as THREE from "three";
import lerp from "lerp"
import useSound from 'use-sound'

import HitSfx from './sounds/Player_Hit.wav'
import HitSfx2 from './sounds/Player_Hit_2.wav'
import alertSfx from './sounds/Alert.wav'
import { COLLISION_GROUP, CORONA_STATUS, useOutline, useAssets, playerApi, useCorona } from "./store"
import Exclamation from './Exclamation';
import Pow from './Pow';

const ATTACK_DURATION = 10

function PhyCorona(props) {
  const { id, initPosition, store } = props
  const [useMyCorona] = store

  const { status, orientation, actions, isUnderAttack, seekAlert } = useMyCorona(s => s)
  const removeCorona = useCorona(s => s.actions.removeCorona)
  const { setStatus, handleAttack: _handleAttack, update } = actions

  const time = useRef(0)
  const attackPosition = useRef()

  const { playerBody } = playerApi.getState()

  const [coronaBody, coronaBodyApi] = useSphere(() => ({
    args: 0.2,
    mass: 1,
    position: initPosition,
    type: "Kinematic",
    collisionFilter: COLLISION_GROUP.CORONA,
    collisionFilterMask: COLLISION_GROUP.CHEST | COLLISION_GROUP.BAT | COLLISION_GROUP.CORONA | COLLISION_GROUP.TILES,
    onCollide: e => handleCollide(e)
  }))

  const handleCollide = useCallback(
    function handleCollide(e) {

      const { contact, body } = e
      const { ni } = contact

      coronaBodyApi.rotation.set(
        coronaBody.current.rotation.x + ni[0],
        coronaBody.current.rotation.y + ni[1],
        coronaBody.current.rotation.z + ni[2]
      )

      if (body?.userData?.type === COLLISION_GROUP.BAT) {
        _handleAttack()
      }

    },
    [coronaBody, coronaBodyApi, _handleAttack]
  )

  const handleAttack = useCallback(
    function handleAttack() {

      if (time.current === 0) {

        attackPosition.current = [
          new THREE.Vector3(playerBody.current.position.x, coronaBody.current.position.y, playerBody.current.position.z),
          coronaBody.current.position.clone()
        ]

      } else if (time.current < ATTACK_DURATION * 2) {

        const { x, y, z } = attackPosition.current[time.current < ATTACK_DURATION ? 0 : 1]

        coronaBodyApi.position.set(
          lerp(coronaBody.current.position.x, x, 0.2),
          lerp(coronaBody.current.position.y, y, 0.2),
          lerp(coronaBody.current.position.z, z, 0.2)
        )

      }

      if (time.current === ATTACK_DURATION * 4) {

        setStatus(CORONA_STATUS.SEEKING)
        time.current = 0

      } else {

        time.current += 1

      }

    },
    [time, coronaBody, coronaBodyApi, setStatus, playerBody, coronaBody]
  )

  const handleDeath = useCallback(
    function handleDeath() {
      const dir = new THREE.Vector3()
      dir.subVectors(playerBody.current.position, coronaBody.current.position).normalize();
      const x = -50 * (dir.x + (0.5 * Math.random() * (Math.random() > 0.5 ? -1 : +1)))
      const y = Math.random()
      const z = -50 * (dir.z + (0.5 * Math.random() * (Math.random() > 0.5 ? -1 : +1)))
      coronaBodyApi.velocity.set(x, y, z)
    },
    [coronaBody, coronaBodyApi, playerBody]
  )

  const onFrame = useCallback(
    function onFrame() {

      if (status === CORONA_STATUS.DEAD) return

      update(coronaBody.current.position)

      if (status === CORONA_STATUS.ATTACK) {

        handleAttack()

      } else {

        const velocityFactor = status === CORONA_STATUS.IDLE ? 1 / 50 : 1 / 30
        coronaBodyApi.position.set(
          coronaBody.current.position.x + orientation.x * velocityFactor,
          initPosition[1],
          coronaBody.current.position.z + orientation.z * velocityFactor
        )

      }
    },
    [coronaBody, coronaBodyApi, initPosition, handleAttack, orientation, update, status]
  )

  useEffect(() => void (status === CORONA_STATUS.DEAD && handleDeath()), [handleDeath, status])

  useFrame(onFrame)

  return (
    <>
      <mesh ref={coronaBody} userData={{ type: COLLISION_GROUP.CORONA, id }} />
      <CoronaRenderer
        ref={coronaBody}
        {...props}
        status={status}
        isUnderAttack={isUnderAttack}
        seekAlert={seekAlert}
        onDeathAnimEnd={removeCorona}
      />
      <CoronaHowler
        isUnderAttack={isUnderAttack}
        seekAlert={seekAlert}
      />
    </>
  )
}

const CoronaHowler = React.memo(function CoronaHowler({ isUnderAttack, seekAlert }) {
  const rand = React.useRef(Math.floor(Math.random() * 10) + 1)

  const [playHitSfx] = useSound(rand.current > 5 ? HitSfx : HitSfx2)
  const [playAlertSfx] = useSound(alertSfx)

  useEffect(() => void (seekAlert && playAlertSfx()), [seekAlert, playAlertSfx])
  useEffect(() => void (isUnderAttack && playHitSfx()), [isUnderAttack, playHitSfx])

  return null
})

const CoronaRenderer = React.memo(forwardRef(
  function CoronaRenderer(props, ref) {
    const { id, status, isUnderAttack, seekAlert, onDeathAnimEnd } = props

    const rand = React.useRef(Math.floor(Math.random() * 10) + 1)

    const group = useRef()
    const rotationGroup = useRef()

    const nodes = useAssets(s => s.coronaNodes)

    const { addOutline, removeOutline } = useOutline(s => s)

    const [resourceRef, material] = useResource()

    const [springProps, set] = useSpring(() => ({ opacity: 1, config: config.molasses }))

    const handleDeath = useCallback(() => {
      removeOutline(group.current)
      set({ opacity: 0, config: config.molasses, onRest: () => onDeathAnimEnd(id) })
    }, [id, group, removeOutline, set, onDeathAnimEnd])

    useEffect(() => void addOutline(group.current), [addOutline, group]);

    useEffect(() => void (status === CORONA_STATUS.DEAD && handleDeath()), [status, handleDeath])

    useFrame(({ clock }) => {

      const multiplier = 10 * (status === CORONA_STATUS.SEEKING ? 2 : 1)
      group.current.position.copy(ref.current.position)
      rotationGroup.current.rotation.copy(ref.current.rotation)
      group.current.position.y += 0.1 * (Math.sin((clock.getElapsedTime() % (2 * Math.PI)) * multiplier + rand.current * 5))

    })

    return (
      <>
        <a.meshToonMaterial
          transparent
          color={status === CORONA_STATUS.DEAD ? 0xff0000 : 0x1E9983}
          shininess={0.3}
          specular={0xaaaaaa}
          ref={resourceRef}
          {...springProps}
        />

        <group ref={group} dispose={null} scale={[0.1, 0.1, 0.1]} >

          <Suspense fallback={null}>
            <Exclamation position={[0, 2.5, 0]} scale={[2, 2, 1]} visible={seekAlert} />
            <Pow position={[0, 1.5, 0]} scale={[2, 2, 1]} visible={isUnderAttack} />
          </Suspense>

          <group ref={rotationGroup} >
            <mesh castShadow material={material} geometry={nodes?.Cube_0?.geometry} name="Cube_0" />
            <mesh castShadow material={material} geometry={nodes?.Cube_1?.geometry} name="Cube_1" />
            <mesh castShadow material={material} geometry={nodes?.Cube_2?.geometry} name="Cube_2" />
            <mesh castShadow material={material} geometry={nodes?.Cube_3?.geometry} name="Cube_3" />
          </group>

        </group>
      </>
    )
  }
))

export default PhyCorona
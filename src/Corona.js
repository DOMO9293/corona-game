/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import React, { useRef, useEffect, useState, useCallback, forwardRef, Suspense } from 'react'
import { useLoader, useFrame, useResource } from 'react-three-fiber'
import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader";
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import { useSphere, useParticle, useLockConstraint, useConeTwistConstraint } from 'use-cannon';
import { useSpring, a, config } from 'react-spring/three';
import * as THREE from "three";
import lerp from "lerp"

import useSound from 'use-sound'

import HitSfx from './sounds/Hit.wav'
import HitSfx2 from './sounds/Hit_2.wav'

import { COLLISION_GROUP, bodyRef, useOutline, useCorona, usePlayerAttack } from "./store"
import { getRandomUnity } from './utils';
import Exclamation from './Exclamation';
import Pow from './Pow';

const ATTACK_DURATION = 10
const Y_BIAS = .6

function PhyCorona(props) {
  const { id, position, isDead, isAttacking, isSeeking } = props

  const [isUnderAttack, setIsUnderAttack] = useState(false)
  
  const time = useRef(0)
  const velocity = useRef()
  const attackPosition = useRef()
  const orientation = useRef()
  const onCollide = useRef()
  const raycast = useRef(new THREE.Raycaster())

  const {
    removeCorona,
    decreaseLife,
    setAttacking,
    resetAttacking,
    setSeeking,
    resetSeeking,
  } = useCorona(s => s)

  const isPlayerAttacking = usePlayerAttack(s => s.isAttacking)

  const [playHitSfx, hitSfxMeta] = useSound(HitSfx)
  const [playHitSfx2, hitSfx2Meta] = useSound(HitSfx2)
  
  const [mybody, mybodyApi] = useSphere(() => ({
    args: 0.2,
    mass: 0.2,
    position: [position[0], position[1] + Y_BIAS, position[2]],
    collisionFilter: COLLISION_GROUP.CORONA,
    collisionFilterMask: COLLISION_GROUP.CHEST | COLLISION_GROUP.BAT | COLLISION_GROUP.CORONA | COLLISION_GROUP.TILES,
    onCollide: e => onCollide.current(e)
  }))

  const [lock, lockApi] = useParticle(() => ({
    args: [0.05, 0.2, 0.5, 16],
    position: [position[0], position[1] + Y_BIAS, position[2]],
    material: { friction: 0, restitution: 0.2 },
    linearDamping: 0.1,
    angularDamping: 0.1,
    type: "Kinetic"
  }))

  const [, , { disable }] = useLockConstraint(mybody, lock)

  const handleCollide = useCallback(
    function handleCollide(e) {

      const { contact, body } = e
      const { impactVelocity, ni } = contact

      mybodyApi.rotation.set(
        mybody.current.rotation.x + ni[0],
        mybody.current.rotation.y + ni[1],
        mybody.current.rotation.z + ni[2]
      )

      if (isPlayerAttacking && body?.userData?.type === COLLISION_GROUP.BAT) {
        const absVelocity = Math.abs(impactVelocity)
        decreaseLife(id, absVelocity)
        setIsUnderAttack(s => { if (!s) return true })
      }

    },
    [id, mybody, bodyRef, mybodyApi, isPlayerAttacking, disable, decreaseLife]
  )

  const updateOrientation = useCallback(
    function updateOrientation() {
      velocity.current = new THREE.Vector2(getRandomUnity(), getRandomUnity()).normalize()
      orientation.current = new THREE.Vector3(velocity.current.x, 0, velocity.current.y).normalize()
    },
    [velocity, orientation]
  )

  const getIntersects = useCallback(
    function getIntersects(position, orientation, scene, collisionArray) {

      raycast.current.set(position, orientation)
      const intersects = raycast.current.intersectObjects(scene.children);

      return intersects.filter(({ object }) => collisionArray.includes(object?.userData?.type))
    }, [raycast])

  const updatePosition = useCallback(
    function updatePosition(scene) {
      const bodies = getIntersects(mybody.current.position, orientation.current, scene, [COLLISION_GROUP.BODY, COLLISION_GROUP.CORONA])
      const tiles = getIntersects(
        new THREE.Vector3(
          mybody.current.position.x + velocity.current.x / 25,
          mybody.current.position.y,
          mybody.current.position.z + velocity.current.y / 25
        ),
        new THREE.Vector3(0, -1, 0),
        scene,
        [COLLISION_GROUP.TILES]
      )

      if (bodies?.[0]?.distance < 0.5 || tiles?.length === 0) {
        updateOrientation()
      } else {
        lockApi.position.set(lock.current.position.x + velocity.current.x / 50, position[1] + Y_BIAS, lock.current.position.z + velocity.current.y / 50)
      }
    },
    [raycast, mybody, orientation, lockApi, updateOrientation, velocity]
  )

  const seekBody = useCallback(
    function seekBody() {
      const dir = new THREE.Vector3()
      dir.subVectors(bodyRef.current.position, mybody.current.position).normalize();

      lockApi.position.set(lock.current.position.x + dir.x / 40, position[1] + Y_BIAS, lock.current.position.z + dir.z / 40)
    },
    [bodyRef, mybody, lockApi]
  )

  const checkProximityToBody = useCallback(
    function checkProximityToBody(scene) {
      const line = new THREE.Line3(mybody.current.position, bodyRef.current.position)
      const distance = line.distance()

      if (distance < 1) {
        if (isSeeking) {
          resetSeeking(id)
        }
        if (!isAttacking) {
          setAttacking(id)
          attackPosition.current = [bodyRef.current.position.clone(), mybody.current.position.clone()]
          time.current = 0
        }

      } else if (distance >= 1 && distance < 4) {

        if (isAttacking) {
          resetAttacking(id)
        }

        const dir = new THREE.Vector3()
        dir.subVectors(bodyRef.current.position, mybody.current.position).normalize();

        raycast.current.set(mybody.current.position, dir)
        const intersect = raycast.current.intersectObjects(scene.children);

        if (intersect[0]?.object?.userData?.type === COLLISION_GROUP.CHEST && !isSeeking) {
          setSeeking(id)
        }

      } else {
        if (isSeeking) {
          resetSeeking(id)
        }
        if (isAttacking) {
          resetAttacking(id)
        }
      }
    },
    [id, raycast, isSeeking, setSeeking, resetSeeking, setAttacking, resetAttacking, isAttacking]
  )

  const handleAttack = useCallback(
    function handleAttack() {
      if (!attackPosition.current) return



      if (time.current < ATTACK_DURATION * 2) {

        const { x, y, z } = attackPosition.current[time.current < ATTACK_DURATION ? 0 : 1]
        lockApi.position.set(
          lerp(lock.current.position.x, x, 0.2),
          lerp(lock.current.position.y, y, 0.2),
          lerp(lock.current.position.z, z, 0.2)
        )

      }
      if (time.current === ATTACK_DURATION * 4) {
        resetAttacking(id)
      }

      time.current += 1
    },
    [time, resetAttacking, id]
  )

  useEffect(() => void (onCollide.current = handleCollide), [onCollide, handleCollide])

  useEffect(() => {
    if (isDead) {
      disable()

      const dir = new THREE.Vector3()
      dir.subVectors(bodyRef.current.position, mybody.current.position).normalize();
      mybodyApi.applyLocalImpulse([-3 * dir.x, -3, -3 * dir.z], [1, 1, 1])
    }
  }, [isDead, bodyRef, mybody, mybodyApi])

  useEffect(() => void updateOrientation(), [updateOrientation])

  useEffect(() => {
    if (isUnderAttack) {
      setTimeout(() => setIsUnderAttack(false), 300)
    }
  }, [isUnderAttack, setIsUnderAttack])

  useFrame(({ scene }) => {
    if (!isDead) {
      checkProximityToBody(scene)

      if (isAttacking) {
        handleAttack()
      } else if (isSeeking) {
        seekBody()
      } else {
        updatePosition(scene)
      }
    }
  })

  return (
    <>
      <mesh ref={lock} />
      <mesh ref={mybody} userData={{ type: COLLISION_GROUP.CORONA, id }} />
      <Suspense fallback={null}>
        <Corona ref={mybody} removeCorona={removeCorona} isUnderAttack={isUnderAttack} {...props} />
      </Suspense>
    </>
  )
}

const Corona = forwardRef((props, ref) => {
  const group = useRef()
  const { id, isDead, isAttacking, isSeeking, isUnderAttack, removeCorona } = props

  const { addOutline, removeOutline } = useOutline(s => s)
  
  const { nodes } = useLoader(GLTFLoader, '/corona.glb',
    loader => {
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath("/draco-gltf/");
      loader.setDRACOLoader(dracoLoader);
    }
  )
  
  const [springProps, set] = useSpring(() => ({ opacity: 1, config: config.molasses }))
  
  const [resourceRef, material] = useResource()
  
  useEffect(() => void addOutline(group.current), [addOutline, group]);
  useEffect(() => {
    if (isDead) {
      removeOutline(group.current)
      set({ opacity: 0, config: config.molasses, onRest: () => removeCorona(id) })
    }
  }, [isDead])

  useFrame(() => {
    group.current.position.copy(ref.current.position)
    group.current.rotation.copy(ref.current.rotation)
  })

  return (
    <>
      <a.meshToonMaterial
        transparent
        color={isDead ? 0xff0000 : 0x1E9983}
        shininess={0.3}
        specular={0xaaaaaa}
        ref={resourceRef}
        {...springProps}
      />

      <group ref={group} dispose={null} scale={[0.1, 0.1, 0.1]} >
        <Suspense fallback={null}>
          <Exclamation position={[0,2.5,0]} scale={[2,2,1]} visible={(isSeeking && !isAttacking)}/>
          <Pow position={[0, 1.5, 0]} scale={[2, 2, 1]} visible={isUnderAttack && !isSeeking} />
        </Suspense>
        <mesh castShadow material={material} geometry={nodes.Cube_0.geometry} name="Cube_0" />
        <mesh castShadow material={material} geometry={nodes.Cube_1.geometry} name="Cube_1" />
        <mesh castShadow material={material} geometry={nodes.Cube_2.geometry} name="Cube_2" />
        <mesh castShadow material={material} geometry={nodes.Cube_3.geometry} name="Cube_3" />
      </group>
    </>
  )
})

export default PhyCorona